'''

Takes a dir cluster, a FAT and multiple CSV generated by
parse_fat32_dir.py and outputs to files.csv all files and their clusters
whose parent is the cluster given as argument.
Works recursively

Created by JoÃ£o Godinho, Jan 2017
'''
import argparse
import struct
import csv


def main():
    parser = argparse.ArgumentParser('Takes a cluster, FAT and multiple CSVs and generates a list of files and clusters.')
    parser.add_argument('dir_cluster', help='The directory cluster number (decimal)', type=int)
    parser.add_argument('fat_file', help='The FAT file, from which links can be extracted')
    parser.add_argument('dirs_csv', help='The CSVs generated by parse_fat32_dir.py containing the dir structure', nargs='+')
    args = parser.parse_args()
    result = get_files(args.dir_cluster, args.fat_file, args.dirs_csv)
    with open('files.csv', 'w') as file:
        fieldnames = sorted(result[0].keys())
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()
        for r in result:
            writer.writerow(r)


# Main workload. When reading CSVs,
# headers should be ones generated
# by parse_fat32_dir.py
def get_files(dir_cluster, fat_file, csv_list):
    # Load the FAT into memory
    with open(fat_file, 'rb') as file:
        FAT = file.read()

    return parse_csv_list(dir_cluster, FAT, csv_list)


# Cycle that handles the extraction from the csvs,
# can be called recursively to handle dir depths > 1
def parse_csv_list(cluster, fat, csv_list):
    result = []
    # Current dir
    CURR_DIR = '.          '
    PARE_DIR = '..         '
    # Extract the result files/dirs
    for c in csv_list:
        with open(c, 'r') as csvfile:
            reader = csv.DictReader(csvfile)
            # Check current and parent dir
            curr_dir = next(reader)
            parent_dir = next(reader)
            # Breaks if format is not expected
            assert curr_dir['name'] == CURR_DIR and parent_dir['name'] == PARE_DIR
            # For what I need, checking for the correct parent is enough, can be
            # extended to check current dir also
            if int(parent_dir['cluster']) == cluster:
            # if int(curr_dir['cluster']) == cluster:
                for row in reader:
                    if row['deleted'] == 'No':
                        if row['type'] == 'File':
                            temp = dict()
                            temp['size'] = row['size']
                            temp['name'] = row['name']
                            temp['clusters'] = []
                            next_cluster = int(row['cluster'])
                            while True:
                                temp['clusters'].append(str(next_cluster))
                                next_cluster = get_next_cluster(fat, next_cluster)
                                if next_cluster is None:
                                    break
                            temp['clusters'] = ';'.join(temp['clusters'])
                            result.append(temp)
                        elif row['type'] == 'Dir':
                            result = result + parse_csv_list(int(row['cluster']), fat, csv_list)
                        else:
                            raise Exception('Unknown type: {0}'.format(row['type']))
    return result


# Takes a FAT and a cluster and returns
# the next cluster or None if last
def get_next_cluster(fat, cluster):
    # Mask to remove the top 4 bits, which are reserved for w/e
    MASK = 0x0FFFFFFF
    # End of cluster chain is the same as the mask
    LAST = MASK
    # Every cluster takes 4 bytes
    cluster = cluster * 4
    next_cluster = struct.unpack('<L', fat[cluster:cluster + 4])[0] & MASK
    if not next_cluster ^ LAST:
        return None
    else:
        return next_cluster

if __name__ == '__main__':
    main()
